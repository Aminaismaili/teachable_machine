import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import pickle
from PIL import Image
import os
import cv2
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import (
    accuracy_score, precision_score, recall_score, f1_score,
    confusion_matrix, classification_report, mean_squared_error,
    mean_absolute_error, r2_score
)

# Classification algorithms
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.naive_bayes import GaussianNB

# Regression algorithms
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, AdaBoostRegressor
from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor

# Deep Learning
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, models
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Configuration de la page
st.set_page_config(
    page_title="Teachable Machine",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Style CSS personnalis√© - TH√àME NOIR
st.markdown("""
    <style>
    .main {
        background-color: #0E1117;
        color: #FAFAFA;
    }
    .stApp {
        background: linear-gradient(135deg, #0E1117 0%, #1E1E1E 50%, #0E1117 100%);
        color: #FAFAFA;
    }
    .stSidebar {
        background: linear-gradient(180deg, #1E1E1E 0%, #0E1117 100%);
    }
    h1, h2, h3, h4, h5, h6 {
        color: #FFFFFF;
        font-weight: bold;
    }
    .stRadio > label {
        color: #FFFFFF !important;
    }
    .stSelectbox > label {
        color: #FFFFFF !important;
    }
    .stMultiSelect > label {
        color: #FFFFFF !important;
    }
    .stSlider > label {
        color: #FFFFFF !important;
    }
    .stNumberInput > label {
        color: #FFFFFF !important;
    }
    .stButton>button {
        width: 100%;
        background: linear-gradient(to right, #667eea, #764ba2);
        color: white;
        font-weight: bold;
        border-radius: 10px;
        padding: 15px;
        border: none;
        transition: all 0.3s ease;
    }
    .stButton>button:hover {
        transform: scale(1.02);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    .stDataFrame {
        background-color: #1E1E1E;
        color: #FAFAFA;
    }
    .stMetric {
        background-color: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        padding: 10px;
        border: 1px solid #333;
    }
    .css-1d391kg, .css-12oz5g7 {
        background-color: #0E1117;
    }
    .stAlert {
        background-color: rgba(30, 30, 30, 0.8);
        border: 1px solid #444;
    }
    .stProgress > div > div > div {
        background: linear-gradient(to right, #667eea, #764ba2);
    }
    .stMarkdown {
        color: #FAFAFA;
    }
    .stFileUploader > label {
        color: #FFFFFF !important;
    }
    .stFileUploader {
        background-color: rgba(30, 30, 30, 0.5);
        border-radius: 10px;
        padding: 20px;
        border: 2px dashed #444;
    }
    div[data-baseweb="select"] > div {
        background-color: #1E1E1E;
        color: #FAFAFA;
    }
    div[data-baseweb="input"] > div {
        background-color: #1E1E1E;
        color: #FAFAFA;
    }
    .stRadio [role="radiogroup"] {
        background-color: #1E1E1E;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #333;
    }
    .stSelectbox [data-baseweb="select"] {
        background-color: #1E1E1E;
        color: #FAFAFA;
    }
    .stMultiSelect [data-baseweb="select"] {
        background-color: #1E1E1E;
        color: #FAFAFA;
    }
    .stSlider [data-baseweb="slider"] {
        color: #667eea;
    }
    </style>
""", unsafe_allow_html=True)

# Configuration matplotlib pour le th√®me noir
plt.rcParams['figure.facecolor'] = '#1E1E1E'
plt.rcParams['axes.facecolor'] = '#1E1E1E'
plt.rcParams['axes.edgecolor'] = '#FFFFFF'
plt.rcParams['axes.labelcolor'] = '#FFFFFF'
plt.rcParams['text.color'] = '#FFFFFF'
plt.rcParams['xtick.color'] = '#FFFFFF'
plt.rcParams['ytick.color'] = '#FFFFFF'
plt.rcParams['grid.color'] = '#444444'

# ==================== CLASSES ====================

class DataProcessor:
    """Classe pour le preprocessing des donn√©es"""
    
    def _init_(self):
        self.scaler = StandardScaler()
        self.label_encoders = {}
        
    def load_data(self, file):
        """Charge les donn√©es depuis un fichier"""
        try:
            if file.name.endswith('.csv'):
                df = pd.read_csv(file)
            elif file.name.endswith(('.xls', '.xlsx')):
                df = pd.read_excel(file)
            else:
                return None, "Format non support√©"
            return df, None
        except Exception as e:
            return None, str(e)
    
    def preprocess_data(self, df, target_col, test_size=0.2, random_state=42):
        """Pr√©traitement des donn√©es tabulaires"""
        # S√©paration features et target
        X = df.drop(columns=[target_col])
        y = df[target_col]
        
        # Encodage des variables cat√©gorielles dans X
        for col in X.select_dtypes(include=['object']).columns:
            le = LabelEncoder()
            X[col] = le.fit_transform(X[col].astype(str))
            self.label_encoders[col] = le
        
        # Encodage de y si cat√©goriel
        if y.dtype == 'object':
            le = LabelEncoder()
            y = le.fit_transform(y)
            self.label_encoders[target_col] = le
        
        # Split des donn√©es
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=random_state
        )
        
        # Normalisation
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        return X_train_scaled, X_test_scaled, y_train, y_test, X.columns

class ImageProcessor:
    """Classe pour le traitement des images"""
    
    def _init_(self, img_size=(128, 128)):
        self.img_size = img_size
        self.label_encoder = LabelEncoder()
        
    def load_images_from_zip(self, zip_file):
        """Charge les images depuis un fichier zip"""
        import zipfile
        import tempfile
        
        images = []
        labels = []
        
        with tempfile.TemporaryDirectory() as temp_dir:
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                zip_ref.extractall(temp_dir)
            
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    if file.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.tiff')):
                        # Le nom du dossier est le label
                        label = os.path.basename(root)
                        img_path = os.path.join(root, file)
                        
                        try:
                            # Charger et pr√©traiter l'image
                            img = Image.open(img_path)
                            img = img.convert('RGB')
                            img = img.resize(self.img_size)
                            img_array = np.array(img) / 255.0
                            
                            images.append(img_array)
                            labels.append(label)
                        except Exception as e:
                            st.warning(f"Impossible de charger l'image {file}: {e}")
        
        return np.array(images), np.array(labels)
    
    def load_images_from_folders(self, uploaded_files):
        """Charge les images depuis des fichiers upload√©s"""
        images = []
        labels = []
        
        for uploaded_file in uploaded_files:
            if uploaded_file.name.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.tiff')):
                try:
                    # Utiliser le nom du fichier ou du dossier comme label
                    label = uploaded_file.name.split('_')[0]  # Premi√®re partie du nom comme label
                    
                    # Charger et pr√©traiter l'image
                    img = Image.open(uploaded_file)
                    img = img.convert('RGB')
                    img = img.resize(self.img_size)
                    img_array = np.array(img) / 255.0
                    
                    images.append(img_array)
                    labels.append(label)
                except Exception as e:
                    st.warning(f"Impossible de charger l'image {uploaded_file.name}: {e}")
        
        return np.array(images), np.array(labels)
    
    def preprocess_images(self, images, labels, test_size=0.2, random_state=42):
        """Pr√©traitement des images"""
        # Encodage des labels
        y_encoded = self.label_encoder.fit_transform(labels)
        
        # Split des donn√©es
        X_train, X_test, y_train, y_test = train_test_split(
            images, y_encoded, test_size=test_size, random_state=random_state
        )
        
        return X_train, X_test, y_train, y_test

class ClassicalMLTrainer:
    """Classe pour entra√Æner les mod√®les ML classiques"""
    
    def _init_(self, problem_type='classification'):
        self.problem_type = problem_type
        self.models = {}
        self.results = {}
        
    def get_models(self):
        """Retourne les mod√®les disponibles selon le type de probl√®me"""
        if self.problem_type == 'classification':
            return {
                'Random Forest': RandomForestClassifier(random_state=42),
                'Logistic Regression': LogisticRegression(random_state=42, max_iter=1000),
                'SVM': SVC(random_state=42),
                'KNN': KNeighborsClassifier(),
                'Decision Tree': DecisionTreeClassifier(random_state=42),
                'Gradient Boosting': GradientBoostingClassifier(random_state=42),
                'AdaBoost': AdaBoostClassifier(random_state=42),
                'Naive Bayes': GaussianNB()
            }
        else:  # regression
            return {
                'Random Forest': RandomForestRegressor(random_state=42),
                'Linear Regression': LinearRegression(),
                'Ridge': Ridge(random_state=42),
                'Lasso': Lasso(random_state=42),
                'ElasticNet': ElasticNet(random_state=42),
                'SVR': SVR(),
                'KNN': KNeighborsRegressor(),
                'Decision Tree': DecisionTreeRegressor(random_state=42),
                'Gradient Boosting': GradientBoostingRegressor(random_state=42)
            }
    
    def train_models(self, X_train, X_test, y_train, y_test, selected_models):
        """Entra√Æne les mod√®les s√©lectionn√©s"""
        available_models = self.get_models()
        
        for model_name in selected_models:
            if model_name in available_models:
                with st.spinner(f'üîÑ Entra√Ænement de {model_name}...'):
                    model = available_models[model_name]
                    model.fit(X_train, y_train)
                    y_pred = model.predict(X_test)
                    
                    self.models[model_name] = model
                    self.results[model_name] = {
                        'predictions': y_pred,
                        'metrics': self._calculate_metrics(y_test, y_pred)
                    }
        
        return self.results
    
    def _calculate_metrics(self, y_true, y_pred):
        """Calcule les m√©triques selon le type de probl√®me"""
        if self.problem_type == 'classification':
            return {
                'Accuracy': accuracy_score(y_true, y_pred),
                'Precision': precision_score(y_true, y_pred, average='weighted', zero_division=0),
                'Recall': recall_score(y_true, y_pred, average='weighted', zero_division=0),
                'F1-Score': f1_score(y_true, y_pred, average='weighted', zero_division=0)
            }
        else:  # regression
            return {
                'R¬≤ Score': r2_score(y_true, y_pred),
                'MSE': mean_squared_error(y_true, y_pred),
                'RMSE': np.sqrt(mean_squared_error(y_true, y_pred)),
                'MAE': mean_absolute_error(y_true, y_pred)
            }

class DeepLearningTrainer:
    """Classe pour cr√©er et entra√Æner des r√©seaux de neurones"""
    
    def _init_(self, problem_type='classification', input_shape=None):
        self.problem_type = problem_type
        self.input_shape = input_shape
        self.model = None
        self.history = None
        
    def build_model(self, input_dim, output_dim, architecture='default', custom_params=None):
        """Construit un r√©seau de neurones pour donn√©es tabulaires"""
        model = models.Sequential()
        
        if architecture == 'default':
            # Architecture par d√©faut
            model.add(layers.Dense(128, activation='relu', input_shape=(input_dim,)))
            model.add(layers.Dropout(0.3))
            model.add(layers.Dense(64, activation='relu'))
            model.add(layers.Dropout(0.3))
            model.add(layers.Dense(32, activation='relu'))
        else:
            # Architecture personnalis√©e
            n_layers = custom_params.get('n_layers', 3)
            neurons = custom_params.get('neurons', 128)
            dropout = custom_params.get('dropout', 0.3)
            
            model.add(layers.Dense(neurons, activation='relu', input_shape=(input_dim,)))
            model.add(layers.Dropout(dropout))
            
            for i in range(n_layers - 1):
                neurons = neurons // 2
                model.add(layers.Dense(neurons, activation='relu'))
                model.add(layers.Dropout(dropout))
        
        # Couche de sortie
        if self.problem_type == 'classification':
            if output_dim == 2:
                model.add(layers.Dense(1, activation='sigmoid'))
                model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
            else:
                model.add(layers.Dense(output_dim, activation='softmax'))
                model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        else:  # regression
            model.add(layers.Dense(1))
            model.compile(optimizer='adam', loss='mse', metrics=['mae'])
        
        self.model = model
        return model
    
    def build_cnn_model(self, output_dim, architecture='default', custom_params=None):
        """Construit un mod√®le CNN pour les images"""
        model = models.Sequential()
        
        if architecture == 'default':
            # Architecture CNN par d√©faut
            model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=self.input_shape))
            model.add(layers.MaxPooling2D((2, 2)))
            model.add(layers.Conv2D(64, (3, 3), activation='relu'))
            model.add(layers.MaxPooling2D((2, 2)))
            model.add(layers.Conv2D(64, (3, 3), activation='relu'))
            model.add(layers.Flatten())
            model.add(layers.Dense(64, activation='relu'))
            model.add(layers.Dropout(0.5))
        else:
            # Architecture personnalis√©e
            n_conv_layers = custom_params.get('n_conv_layers', 3)
            filters = custom_params.get('filters', 32)
            dense_neurons = custom_params.get('dense_neurons', 64)
            dropout = custom_params.get('dropout', 0.5)
            
            model.add(layers.Conv2D(filters, (3, 3), activation='relu', input_shape=self.input_shape))
            model.add(layers.MaxPooling2D((2, 2)))
            
            for i in range(n_conv_layers - 1):
                filters *= 2
                model.add(layers.Conv2D(filters, (3, 3), activation='relu'))
                model.add(layers.MaxPooling2D((2, 2)))
            
            model.add(layers.Flatten())
            model.add(layers.Dense(dense_neurons, activation='relu'))
            model.add(layers.Dropout(dropout))
        
        # Couche de sortie
        if output_dim == 2:
            model.add(layers.Dense(1, activation='sigmoid'))
            model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
        else:
            model.add(layers.Dense(output_dim, activation='softmax'))
            model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        
        self.model = model
        return model
    
    def train(self, X_train, y_train, X_val, y_val, epochs=100, batch_size=32):
        """Entra√Æne le mod√®le"""
        early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
        
        self.history = self.model.fit(
            X_train, y_train,
            validation_data=(X_val, y_val),
            epochs=epochs,
            batch_size=batch_size,
            callbacks=[early_stopping],
            verbose=0
        )
        
        return self.history
    
    def evaluate(self, X_test, y_test):
        """√âvalue le mod√®le"""
        y_pred = self.model.predict(X_test)
        
        if self.problem_type == 'classification':
            if y_pred.shape[1] == 1:  # Binary
                y_pred_classes = (y_pred > 0.5).astype(int).flatten()
            else:  # Multiclass
                y_pred_classes = np.argmax(y_pred, axis=1)
            
            return {
                'Accuracy': accuracy_score(y_test, y_pred_classes),
                'Precision': precision_score(y_test, y_pred_classes, average='weighted', zero_division=0),
                'Recall': recall_score(y_test, y_pred_classes, average='weighted', zero_division=0),
                'F1-Score': f1_score(y_test, y_pred_classes, average='weighted', zero_division=0)
            }, y_pred_classes
        else:
            return {
                'R¬≤ Score': r2_score(y_test, y_pred),
                'MSE': mean_squared_error(y_test, y_pred),
                'RMSE': np.sqrt(mean_squared_error(y_test, y_pred)),
                'MAE': mean_absolute_error(y_test, y_pred)
            }, y_pred

# ==================== INTERFACE PRINCIPALE ====================

def main():
    # Header avec style noir
    st.markdown("""
        <h1 style='text-align: center; padding: 20px; background: linear-gradient(135deg, #667eea, #764ba2); 
                   -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold;'>
            ü§ñ Teachable Machine - Dark Mode
        </h1>
        <p style='text-align: center; color: #CCCCCC; font-size: 18px;'>
            Entra√Ænez vos mod√®les de Machine Learning avec des donn√©es tabulaires ou des images
        </p>
        <hr style='border: 1px solid #333; margin: 20px 0;'>
    """, unsafe_allow_html=True)
    
    # Initialisation des sessions
    if 'data_loaded' not in st.session_state:
        st.session_state.data_loaded = False
    if 'trained' not in st.session_state:
        st.session_state.trained = False
    if 'data_type' not in st.session_state:
        st.session_state.data_type = None
    
    # Sidebar avec style noir
    with st.sidebar:
        st.markdown("""
            <div style='text-align: center; padding: 10px;'>
                <img src='https://cdn-icons-png.flaticon.com/512/8637/8637099.png' width='80' style='filter: invert(1);'>
            </div>
            <h3 style='text-align: center; color: #FFFFFF;'>üìä Navigation</h3>
            <hr style='border: 1px solid #333; margin: 10px 0;'>
        """, unsafe_allow_html=True)
        
        step = st.radio(
            "√âtapes:",
            ["1Ô∏è‚É£ Upload Data", "2Ô∏è‚É£ Configuration", "3Ô∏è‚É£ Entra√Ænement", "4Ô∏è‚É£ R√©sultats"],
            label_visibility="collapsed"
        )
    
    # ==================== √âTAPE 1: UPLOAD DATA ====================
    if step == "1Ô∏è‚É£ Upload Data":
        st.header("üìÅ Upload vos donn√©es")
        
        # S√©lection du type de donn√©es
        data_type = st.radio(
            "üìä Type de donn√©es:",
            ["üìà Donn√©es Tabulaire (CSV/Excel)", "üñº Images"],
            horizontal=True
        )
        
        st.session_state.data_type = data_type
        
        if "Tabulaire" in data_type:
            uploaded_file = st.file_uploader(
                "Choisissez un fichier CSV ou Excel",
                type=['csv', 'xlsx', 'xls'],
                help="Formats support√©s: CSV, Excel"
            )
            
            if uploaded_file:
                processor = DataProcessor()
                df, error = processor.load_data(uploaded_file)
                
                if error:
                    st.error(f"‚ùå Erreur: {error}")
                else:
                    st.success("‚úÖ Donn√©es tabulaires charg√©es avec succ√®s!")
                    st.session_state.df = df
                    st.session_state.data_loaded = True
                    st.session_state.processor = processor
                    
                    # Aper√ßu des donn√©es
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üìä Lignes", df.shape[0])
                    with col2:
                        st.metric("üìã Colonnes", df.shape[1])
                    with col3:
                        st.metric("üî¢ Types", df.select_dtypes(include=[np.number]).shape[1])
                    
                    st.subheader("üìã Aper√ßu des donn√©es")
                    st.dataframe(df.head(10), use_container_width=True)
                    
                    st.subheader("üìä Informations")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write("*Types de colonnes:*")
                        st.dataframe(df.dtypes.to_frame('Type'), use_container_width=True)
                    
                    with col2:
                        st.write("*Valeurs manquantes:*")
                        missing = df.isnull().sum()
                        st.dataframe(missing.to_frame('Missing'), use_container_width=True)
        
        else:  # Images
            st.subheader("üñº Upload d'Images")
            
            upload_option = st.radio(
                "M√©thode d'upload:",
                ["üìÅ Fichiers multiples", "üóú Archive ZIP"],
                horizontal=True
            )
            
            if upload_option == "üìÅ Fichiers multiples":
                uploaded_files = st.file_uploader(
                    "Choisissez vos images",
                    type=['png', 'jpg', 'jpeg', 'bmp', 'tiff'],
                    accept_multiple_files=True,
                    help="Formats support√©s: PNG, JPG, JPEG, BMP, TIFF"
                )
                
                if uploaded_files:
                    st.success(f"‚úÖ {len(uploaded_files)} images charg√©es!")
                    
                    # Afficher un aper√ßu des images
                    st.subheader("üëÄ Aper√ßu des images")
                    cols = st.columns(4)
                    for idx, uploaded_file in enumerate(uploaded_files[:8]):
                        with cols[idx % 4]:
                            img = Image.open(uploaded_file)
                            st.image(img, caption=uploaded_file.name, width=150)
                    
                    st.session_state.uploaded_files = uploaded_files
                    st.session_state.data_loaded = True
                    st.session_state.image_processor = ImageProcessor()
            
            else:  # Archive ZIP
                zip_file = st.file_uploader(
                    "Choisissez une archive ZIP contenant vos images",
                    type=['zip'],
                    help="Archive ZIP avec des dossiers organis√©s par classe"
                )
                
                if zip_file:
                    st.success("‚úÖ Archive ZIP charg√©e!")
                    st.session_state.zip_file = zip_file
                    st.session_state.data_loaded = True
                    st.session_state.image_processor = ImageProcessor()
    
    # ==================== √âTAPE 2: CONFIGURATION ====================
    elif step == "2Ô∏è‚É£ Configuration":
        if not st.session_state.data_loaded:
            st.warning("‚ö† Veuillez d'abord charger des donn√©es!")
            return
        
        st.header("‚öô Configuration du mod√®le")
        
        # Configuration diff√©rente selon le type de donn√©es
        if "Tabulaire" in st.session_state.data_type:
            df = st.session_state.df
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üéØ Type de probl√®me")
                problem_type = st.radio(
                    "S√©lectionnez:",
                    ["Classification", "R√©gression"],
                    horizontal=True
                )
                st.session_state.problem_type = problem_type.lower()
            
            with col2:
                st.subheader("üß† Type de mod√®le")
                model_type = st.radio(
                    "S√©lectionnez:",
                    ["ML Classique", "Deep Learning"],
                    horizontal=True
                )
                st.session_state.model_type = model_type
            
            st.subheader("üéØ Variable cible")
            target_col = st.selectbox("S√©lectionnez la colonne cible:", df.columns)
            st.session_state.target_col = target_col
            
        else:  # Images
            st.subheader("üéØ Configuration pour les Images")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìä Type de probl√®me")
                problem_type = st.radio(
                    "S√©lectionnez:",
                    ["Classification"],
                    horizontal=True
                )
                st.session_state.problem_type = "classification"
                
                st.subheader("üß† Type de mod√®le")
                model_type = st.radio(
                    "S√©lectionnez:",
                    ["Deep Learning"],
                    horizontal=True
                )
                st.session_state.model_type = "Deep Learning"
            
            with col2:
                st.subheader("üñº Param√®tres des images")
                img_size = st.selectbox(
                    "Taille des images:",
                    [(64, 64), (128, 128), (224, 224)],
                    format_func=lambda x: f"{x[0]}x{x[1]}"
                )
                st.session_state.img_size = img_size
        
        st.subheader("‚úÇ Split des donn√©es")
        col1, col2 = st.columns([3, 1])
        with col1:
            test_size = st.slider(
                "Taille du test set (%)",
                min_value=10,
                max_value=40,
                value=20,
                step=5
            )
        with col2:
            st.metric("Train", f"{100-test_size}%")
            st.metric("Test", f"{test_size}%")
        
        st.session_state.test_size = test_size / 100
        
        if st.button("‚úÖ Valider la configuration", type="primary"):
            st.success("‚úÖ Configuration enregistr√©e! Passez √† l'entra√Ænement.")
    
    # ==================== √âTAPE 3: ENTRA√éNEMENT ====================
    elif step == "3Ô∏è‚É£ Entra√Ænement":
        if not st.session_state.data_loaded:
            st.warning("‚ö† Veuillez d'abord charger des donn√©es!")
            return
        
        if 'target_col' not in st.session_state and "Tabulaire" in st.session_state.data_type:
            st.warning("‚ö† Veuillez d'abord configurer votre mod√®le!")
            return
        
        st.header("üöÄ Entra√Ænement du mod√®le")
        
        # Pr√©paration des donn√©es selon le type
        if "Tabulaire" in st.session_state.data_type:
            # Donn√©es tabulaires
            if 'X_train' not in st.session_state:
                with st.spinner("üîÑ Pr√©paration des donn√©es tabulaires..."):
                    processor = st.session_state.processor
                    X_train, X_test, y_train, y_test, feature_names = processor.preprocess_data(
                        st.session_state.df,
                        st.session_state.target_col,
                        st.session_state.test_size
                    )
                    st.session_state.X_train = X_train
                    st.session_state.X_test = X_test
                    st.session_state.y_train = y_train
                    st.session_state.y_test = y_test
                    st.session_state.feature_names = feature_names
                st.success("‚úÖ Donn√©es pr√©par√©es!")
            
            # ML CLASSIQUE
            if st.session_state.model_type == "ML Classique":
                st.subheader("ü§ñ Algorithmes ML Classiques")
                
                trainer = ClassicalMLTrainer(st.session_state.problem_type)
                available_models = list(trainer.get_models().keys())
                
                selected_models = st.multiselect(
                    "S√©lectionnez les algorithmes √† entra√Æner:",
                    available_models,
                    default=available_models[:3]
                )
                
                if st.button("üöÄ Lancer l'entra√Ænement", type="primary"):
                    if selected_models:
                        # Reshape pour les mod√®les classiques si n√©cessaire
                        if len(st.session_state.X_train.shape) > 2:
                            X_train_flat = st.session_state.X_train.reshape(st.session_state.X_train.shape[0], -1)
                            X_test_flat = st.session_state.X_test.reshape(st.session_state.X_test.shape[0], -1)
                        else:
                            X_train_flat = st.session_state.X_train
                            X_test_flat = st.session_state.X_test
                        
                        results = trainer.train_models(
                            X_train_flat,
                            X_test_flat,
                            st.session_state.y_train,
                            st.session_state.y_test,
                            selected_models
                        )
                        st.session_state.ml_results = results
                        st.session_state.ml_trainer = trainer
                        st.session_state.trained = True
                        st.success("‚úÖ Entra√Ænement termin√©!")
                        st.balloons()
                    else:
                        st.warning("‚ö† Veuillez s√©lectionner au moins un algorithme!")
            
            # DEEP LEARNING pour donn√©es tabulaires
            else:
                st.subheader("üß† Deep Learning pour donn√©es tabulaires")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    architecture = st.radio(
                        "Architecture:",
                        ["default", "custom"]
                    )
                
                custom_params = {}
                if architecture == "custom":
                    with col2:
                        st.write("*Param√®tres personnalis√©s:*")
                        custom_params['n_layers'] = st.number_input("Nombre de couches", 2, 10, 3)
                        custom_params['neurons'] = st.number_input("Neurons (1√®re couche)", 32, 512, 128)
                        custom_params['dropout'] = st.slider("Dropout", 0.0, 0.5, 0.3)
                
                epochs = st.slider("Epochs", 10, 200, 100)
                batch_size = st.selectbox("Batch size", [16, 32, 64, 128], index=1)
                
                if st.button("üöÄ Lancer l'entra√Ænement DL", type="primary"):
                    with st.spinner("üîÑ Entra√Ænement en cours..."):
                        dl_trainer = DeepLearningTrainer(st.session_state.problem_type)
                        
                        input_dim = st.session_state.X_train.shape[1]
                        output_dim = len(np.unique(st.session_state.y_train)) if st.session_state.problem_type == 'classification' else 1
                        
                        model = dl_trainer.build_model(input_dim, output_dim, architecture, custom_params)
                        
                        # Entra√Ænement
                        progress_bar = st.progress(0)
                        history = dl_trainer.train(
                            st.session_state.X_train,
                            st.session_state.y_train,
                            st.session_state.X_test,
                            st.session_state.y_test,
                            epochs=epochs,
                            batch_size=batch_size
                        )
                        progress_bar.progress(100)
                        
                        st.session_state.dl_trainer = dl_trainer
                        st.session_state.dl_history = history
                        st.session_state.trained = True
                        
                    st.success("‚úÖ Entra√Ænement termin√©!")
                    st.balloons()
        
        else:  # Images
            st.subheader("üñº Deep Learning pour Images")
            
            # Pr√©paration des images
            if 'X_train' not in st.session_state:
                with st.spinner("üîÑ Pr√©paration des images..."):
                    image_processor = st.session_state.image_processor
                    image_processor.img_size = st.session_state.img_size
                    
                    if hasattr(st.session_state, 'uploaded_files'):
                        images, labels = image_processor.load_images_from_folders(st.session_state.uploaded_files)
                    else:
                        images, labels = image_processor.load_images_from_zip(st.session_state.zip_file)
                    
                    if len(images) == 0:
                        st.error("‚ùå Aucune image valide n'a √©t√© trouv√©e!")
                        return
                    
                    X_train, X_test, y_train, y_test = image_processor.preprocess_images(
                        images, labels, st.session_state.test_size
                    )
                    
                    st.session_state.X_train = X_train
                    st.session_state.X_test = X_test
                    st.session_state.y_train = y_train
                    st.session_state.y_test = y_test
                    st.session_state.image_processor = image_processor
                    st.session_state.labels = labels
                    
                    st.success(f"‚úÖ {len(images)} images pr√©par√©es! Classes: {np.unique(labels)}")
            
            # Configuration CNN
            col1, col2 = st.columns(2)
            
            with col1:
                architecture = st.radio(
                    "Architecture CNN:",
                    ["default", "custom"]
                )
            
            custom_params = {}
            if architecture == "custom":
                with col2:
                    st.write("*Param√®tres CNN personnalis√©s:*")
                    custom_params['n_conv_layers'] = st.number_input("Nombre de couches convolutionnelles", 2, 5, 3)
                    custom_params['filters'] = st.number_input("Filtres (1√®re couche)", 16, 128, 32)
                    custom_params['dense_neurons'] = st.number_input("Neurons couches denses", 32, 256, 64)
                    custom_params['dropout'] = st.slider("Dropout", 0.0, 0.7, 0.5)
            
            epochs = st.slider("Epochs", 10, 200, 50)
            batch_size = st.selectbox("Batch size", [16, 32, 64], index=1)
            
            if st.button("üöÄ Lancer l'entra√Ænement CNN", type="primary"):
                with st.spinner("üîÑ Entra√Ænement CNN en cours..."):
                    input_shape = st.session_state.X_train.shape[1:]  # (height, width, channels)
                    dl_trainer = DeepLearningTrainer(
                        problem_type='classification',
                        input_shape=input_shape
                    )
                    
                    output_dim = len(np.unique(st.session_state.y_train))
                    
                    model = dl_trainer.build_cnn_model(output_dim, architecture, custom_params)
                    
                    # Aper√ßu du mod√®le
                    st.subheader("üìã Architecture du mod√®le CNN")
                    model_summary = []
                    model.summary(print_fn=lambda x: model_summary.append(x))
                    st.text("\n".join(model_summary))
                    
                    # Entra√Ænement
                    progress_bar = st.progress(0)
                    history = dl_trainer.train(
                        st.session_state.X_train,
                        st.session_state.y_train,
                        st.session_state.X_test,
                        st.session_state.y_test,
                        epochs=epochs,
                        batch_size=batch_size
                    )
                    progress_bar.progress(100)
                    
                    st.session_state.dl_trainer = dl_trainer
                    st.session_state.dl_history = history
                    st.session_state.trained = True
                    
                st.success("‚úÖ Entra√Ænement CNN termin√©!")
                st.balloons()
    
    # ==================== √âTAPE 4: R√âSULTATS ====================
    elif step == "4Ô∏è‚É£ R√©sultats":
        if not st.session_state.trained:
            st.warning("‚ö† Veuillez d'abord entra√Æner un mod√®le!")
            return
        
        st.header("üìä R√©sultats et √âvaluation")
        
        # R√âSULTATS ML CLASSIQUE (seulement pour donn√©es tabulaires)
        if st.session_state.model_type == "ML Classique" and "Tabulaire" in st.session_state.data_type:
            results = st.session_state.ml_results
            
            # Tableau comparatif
            st.subheader("üìà Comparaison des mod√®les")
            
            metrics_df = pd.DataFrame({
                model: res['metrics']
                for model, res in results.items()
            }).T
            
            st.dataframe(metrics_df.style.highlight_max(axis=0, color='#667eea'), use_container_width=True)
            
            # Meilleur mod√®le
            if st.session_state.problem_type == 'classification':
                best_metric = 'Accuracy'
            else:
                best_metric = 'R¬≤ Score'
            
            best_model = metrics_df[best_metric].idxmax()
            best_score = metrics_df[best_metric].max()
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üèÜ Meilleur Mod√®le", best_model)
            with col2:
                st.metric(f"üìä {best_metric}", f"{best_score:.4f}")
            with col3:
                st.metric("üìÅ Mod√®les entra√Æn√©s", len(results))
            
            # Visualisations
            st.subheader("üìä Visualisations")
            
            if st.session_state.problem_type == 'classification':
                # Matrice de confusion pour le meilleur mod√®le
                y_pred = results[best_model]['predictions']
                cm = confusion_matrix(st.session_state.y_test, y_pred)
                
                fig, ax = plt.subplots(figsize=(8, 6))
                im = ax.imshow(cm, interpolation='nearest', cmap='plasma')
                ax.figure.colorbar(im, ax=ax)
                
                # Ajouter les annotations
                thresh = cm.max() / 2.
                for i in range(cm.shape[0]):
                    for j in range(cm.shape[1]):
                        ax.text(j, i, format(cm[i, j], 'd'),
                               ha="center", va="center",
                               color="white" if cm[i, j] > thresh else "black",
                               fontweight='bold')
                
                ax.set_title(f'Matrice de Confusion - {best_model}', fontweight='bold', pad=20)
                ax.set_xlabel('Pr√©dictions', fontweight='bold')
                ax.set_ylabel('Vraies valeurs', fontweight='bold')
                ax.set_xticks(range(len(cm)))
                ax.set_yticks(range(len(cm)))
                st.pyplot(fig)
            
            else:  # regression
                # Pr√©dictions vs R√©elles
                y_pred = results[best_model]['predictions']
                
                fig, ax = plt.subplots(figsize=(10, 6))
                scatter = ax.scatter(st.session_state.y_test, y_pred, alpha=0.6, c='#667eea', s=50)
                ax.plot([st.session_state.y_test.min(), st.session_state.y_test.max()],
                       [st.session_state.y_test.min(), st.session_state.y_test.max()],
                       'r--', lw=2, alpha=0.8)
                ax.set_xlabel('Valeurs r√©elles', fontweight='bold')
                ax.set_ylabel('Pr√©dictions', fontweight='bold')
                ax.set_title(f'Pr√©dictions vs R√©elles - {best_model}', fontweight='bold', pad=20)
                ax.grid(True, alpha=0.3)
                st.pyplot(fig)
            
            # T√©l√©chargement du mod√®le
            st.subheader("üíæ T√©l√©charger le mod√®le")
            model_to_download = st.selectbox("S√©lectionnez un mod√®le:", list(results.keys()))
            
            if st.button("üì• T√©l√©charger"):
                model = st.session_state.ml_trainer.models[model_to_download]
                buffer = BytesIO()
                pickle.dump(model, buffer)
                buffer.seek(0)
                
                st.download_button(
                    label="üíæ T√©l√©charger le mod√®le",
                    data=buffer,
                    file_name=f"{model_to_download.replace(' ', '_')}_model.pkl",
                    mime="application/octet-stream"
                )
        
        # R√âSULTATS DEEP LEARNING (pour donn√©es tabulaires et images)
        else:
            dl_trainer = st.session_state.dl_trainer
            history = st.session_state.dl_history.history
            
            # M√©triques
            metrics, predictions = dl_trainer.evaluate(
                st.session_state.X_test,
                st.session_state.y_test
            )
            
            st.subheader("üìä M√©triques du mod√®le")
            cols = st.columns(len(metrics))
            for idx, (metric, value) in enumerate(metrics.items()):
                with cols[idx]:
                    st.metric(metric, f"{value:.4f}")
            
            # Courbes d'apprentissage
            st.subheader("üìà Courbes d'apprentissage")
            
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))
            
            # Loss
            axes[0].plot(history['loss'], label='Train Loss', linewidth=2, color='#667eea')
            axes[0].plot(history['val_loss'], label='Val Loss', linewidth=2, color='#764ba2')
            axes[0].set_title('Loss durant l\'entra√Ænement', fontweight='bold')
            axes[0].set_xlabel('Epoch')
            axes[0].set_ylabel('Loss')
            axes[0].legend()
            axes[0].grid(True, alpha=0.3)
            
            # M√©trique principale
            metric_key = 'accuracy' if st.session_state.problem_type == 'classification' else 'mae'
            if metric_key in history:
                axes[1].plot(history[metric_key], label=f'Train {metric_key}', linewidth=2, color='#667eea')
                axes[1].plot(history[f'val_{metric_key}'], label=f'Val {metric_key}', linewidth=2, color='#764ba2')
                axes[1].set_title(f'{metric_key.upper()} durant l\'entra√Ænement', fontweight='bold')
                axes[1].set_xlabel('Epoch')
                axes[1].set_ylabel(metric_key.upper())
                axes[1].legend()
                axes[1].grid(True, alpha=0.3)
            
            plt.tight_layout()
            st.pyplot(fig)
            
            # Matrice de confusion pour la classification
            if st.session_state.problem_type == 'classification':
                st.subheader("üéØ Matrice de Confusion")
                y_pred_classes = np.argmax(dl_trainer.model.predict(st.session_state.X_test), axis=1)
                cm = confusion_matrix(st.session_state.y_test, y_pred_classes)
                
                fig, ax = plt.subplots(figsize=(8, 6))
                im = ax.imshow(cm, interpolation='nearest', cmap='plasma')
                ax.figure.colorbar(im, ax=ax)
                
                thresh = cm.max() / 2.
                for i in range(cm.shape[0]):
                    for j in range(cm.shape[1]):
                        ax.text(j, i, format(cm[i, j], 'd'),
                               ha="center", va="center",
                               color="white" if cm[i, j] > thresh else "black",
                               fontweight='bold')
                
                ax.set_title('Matrice de Confusion', fontweight='bold', pad=20)
                ax.set_xlabel('Pr√©dictions', fontweight='bold')
                ax.set_ylabel('Vraies valeurs', fontweight='bold')
                st.pyplot(fig)
            
            # T√©l√©chargement du mod√®le
            st.subheader("üíæ T√©l√©charger le mod√®le")
            if st.button("üì• T√©l√©charger le mod√®le DL"):
                if "Images" in st.session_state.data_type:
                    model_name = "cnn_model.h5"
                else:
                    model_name = "dense_model.h5"
                
                dl_trainer.model.save(model_name)
                with open(model_name, 'rb') as f:
                    st.download_button(
                        label="üíæ T√©l√©charger",
                        data=f,
                        file_name=model_name,
                        mime="application/octet-stream"
                    )
        
        # Bouton pour r√©-entra√Æner
        st.divider()
        if st.button("üîÑ R√©-entra√Æner avec d'autres param√®tres"):
            st.session_state.trained = False
            st.rerun()


if _name_ == "_main_":
    main()
